core:
- Integration hell refers to the problems that arise when developers wait until the
  end of a development cycle to integrate their code with the main development line
details_additional:
- Continuous integration practices can help mitigate integration hell by integrating
  code continuously and verifying that the build remains intact
- Tools like GitHub Actions can be used to automate the integration process and reduce
  the likelihood of integration hell
details_important:
- This can lead to a large number of conflicts and errors that are time-consuming
  to resolve
- Integration hell is often caused by infrequent integration and release events
helps:
- '## Check your understanding (pt. 2)


  - In the context of software engineering, what is integration? What is continuous
  integration?

  - In the context of software engineering, what are the issues arising from infrequent
  integration/release events?

  - In the context of software engineering, how to make integration continuous?

  - What is GitHub Actions? What is its purpose? How does it work?

  - In the context of GitHub Actions, what is the difference among workflow, jobs,
  steps

  - In an ordinary Python project using Poetry for build automation and release on
  PyPi and `unittest` for automatic tests, how would you organize a continuous integration
  pipeline? (What operations should be performed in each run of the pipeline?)


  {{% /section %}}

  '
- '## Check your understanding (pt. 2)


  - In the context of software engineering, what is integration? What is continuous
  integration?

  - In the context of software engineering, what are the issues arising from infrequent
  integration/release events?

  - In the context of software engineering, how to make integration continuous?

  - What is GitHub Actions? What is its purpose? How does it work?

  - In the context of GitHub Actions, what is the difference among workflow, jobs,
  steps

  - In an ordinary Python project using Poetry for build automation and release on
  PyPi and `unittest` for automatic tests, how would you organize a continuous integration
  pipeline? (What operations should be performed in each run of the pipeline?)


  {{% /section %}}

  '
- '# Continuous Integration


  The practice of integrating code with a main development line **continuously**

  <br>

  _Verifying_ that the build remains intact

  * Requires *build automation* to be in place

  * Requires *testing* to be in place

  * Pivot point of the *DevOps* practices

  * Historically introduced by the extreme programming (XP) community

  * Now widespread in the larger DevOps community

  '
- '# Continuous Integration


  The practice of integrating code with a main development line **continuously**

  <br>

  _Verifying_ that the build remains intact

  * Requires *build automation* to be in place

  * Requires *testing* to be in place

  * Pivot point of the *DevOps* practices

  * Historically introduced by the extreme programming (XP) community

  * Now widespread in the larger DevOps community

  '
- '{{% section %}}


  ## Check your understanding (pt. 1)


  - In your own words, what is continuous integration?

  - In your own words, what is integration hell?

  - In the context of continuous integration, what is a pipeline?

  - What is GitHub Actions?

  - In the context of continuous integration, provide an overview of the abstract
  pipeline design

  - In the context of GitHub Actions, what is the difference among workflow, jobs,
  steps

  - How would you design a GitHub Actions workflow for a Python project?

  - In the context of GitHub Actions, what is a runner?

  - What is YAML? What is the difference between YAML and JSON?

  - In the context of GitHub Actions, what is a matrix?

  - In the context of GitHub Actions, what is a secret?

  '
id: CI-2
model_name: llama-3.3-70b-versatile
model_provider: groq
prompt_template: "You are a teacher in the Software Engineering course, for the Digital\
  \ Transformation and Management master programme. \n\nYour task is to create a structured\
  \ checklist for evaluating student answers to each question.\n\nFor each question,\
  \ you should identify:\n\n1. **Core** - The essential elements that MUST be present\
  \ in a perfect answer to address the most important part of the question. These\
  \ are the fundamental concepts, definitions, or explanations that directly answer\
  \ what is being asked.\n\n2. **Important Details** - Significant additional details\
  \ that should be mentioned to enrich the answer. These go beyond the core but are\
  \ important for a complete understanding.\n\n3. **Additional Details** - Optional\
  \ supplementary details that can further improve the answer. These might include\
  \ examples, comparisons, background context, or motivational aspects that add depth\
  \ but are not strictly necessary.\n\nEach item in the lists should be specific,\
  \ verifiable, and actionable - not vague or fluffy.\n\nOnly extract the properties\
  \ mentioned in the '{class_name}' function.\n\nQuestion is:\n    {question}\n\n\
  Below are snippets from the course material that may help you answer the question:\n\
  \n{help}"
question: In your own words, what is integration hell?
