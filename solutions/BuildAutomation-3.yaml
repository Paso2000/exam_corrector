core:
- Automation of the build lifecycle
- Saving time by automating repetitive tasks
- Reducing errors by automating the build process
details_additional:
- Examples of build automation tools such as Apache Maven
- Comparison between imperative and declarative build automation systems
- Discussion of domain-specific languages in hybrid automators
details_important:
- Declarative build automation systems
- Relying on conventions and defaults
- Minimal configuration as long as developers follow conventions
helps:
- '# Build automation


  Automation of the build lifecycle


  * In principle, the lifecycle could be executed manually

  * In reality *time is precious* and *repetitivy is boring* (and __error-prone__)


  > $\Rightarrow$ Create software that automates the building of some software!


  * All those concerns that hold for software creation hold for build systems creation...

  '
- '# Build automation


  Automation of the build lifecycle


  * In principle, the lifecycle could be executed manually

  * In reality *time is precious* and *repetitivy is boring* (and __error-prone__)


  > $\Rightarrow$ Create software that automates the building of some software!


  * All those concerns that hold for software creation hold for build systems creation...

  '
- "<!-- ## Build automation: basics and styles\n\nDifferent lifecycle types generate\
  \ different build automation **styles**\n\n**Imperative**: write a script that tells\
  \ the system what to do to get\nfrom code to artifacts\n* *Examples*: make, cmake,\
  \ Apache Ant\n* *Abstraction gap*: verbose, repetitive\n* Configuration (*declarative*)\
  \ and actionable (*imperative*) logics *mixed* together\n* Highly *configurable*\n\
  \n**Declarative**: adhere to some convention, customizing some settings\n* *Examples*:\
  \ Apache Maven\n* Separation between *what* to do and *how* to do it\n  * The build\
  \ system decides how to do the stuff\n* *Configuration limited* by the provided\
  \ options -->\n\n## __Declarative__ build automation systems\n\nModern build automation\
  \ systems are __declarative__\n\n> __Declarative__ software $\\approx$ the program\
  \ describes *what* to do, not *how* to do it\n> <br>\n> (as opposed to _imperative_\
  \ software $\\approx$ the program describes *how* to do it,\n> <br>\n> e.g. Python)\n\
  \nIn other words:\n- they rely on *conventions* and *defaults*\n- as long as developers\
  \ follow them, the configuration is _minimal_\n- good look if you try to deviate\
  \ from conventions :)\n\n<!-- ---\n\n## Hybrid automators\n\nCreate a *declarative\
  \ infrastructure* upon an *imperative basis*, and\n*allow easy access to the underlying\
  \ machinery*\n\n**Domain-Specific Languages** are helpful in this context: they\
  \ can \"hide\" imperativity without ruling it out\n\nStill, many challenges remain\
  \ open:\n* How to reuse the build logic?\n    * within a project, and among projects\
  \ -->\n"
- "<!-- ## Build automation: basics and styles\n\nDifferent lifecycle types generate\
  \ different build automation **styles**\n\n**Imperative**: write a script that tells\
  \ the system what to do to get\nfrom code to artifacts\n* *Examples*: make, cmake,\
  \ Apache Ant\n* *Abstraction gap*: verbose, repetitive\n* Configuration (*declarative*)\
  \ and actionable (*imperative*) logics *mixed* together\n* Highly *configurable*\n\
  \n**Declarative**: adhere to some convention, customizing some settings\n* *Examples*:\
  \ Apache Maven\n* Separation between *what* to do and *how* to do it\n  * The build\
  \ system decides how to do the stuff\n* *Configuration limited* by the provided\
  \ options -->\n\n## __Declarative__ build automation systems\n\nModern build automation\
  \ systems are __declarative__\n\n> __Declarative__ software $\\approx$ the program\
  \ describes *what* to do, not *how* to do it\n> <br>\n> (as opposed to _imperative_\
  \ software $\\approx$ the program describes *how* to do it,\n> <br>\n> e.g. Python)\n\
  \nIn other words:\n- they rely on *conventions* and *defaults*\n- as long as developers\
  \ follow them, the configuration is _minimal_\n- good look if you try to deviate\
  \ from conventions :)\n\n<!-- ---\n\n## Hybrid automators\n\nCreate a *declarative\
  \ infrastructure* upon an *imperative basis*, and\n*allow easy access to the underlying\
  \ machinery*\n\n**Domain-Specific Languages** are helpful in this context: they\
  \ can \"hide\" imperativity without ruling it out\n\nStill, many challenges remain\
  \ open:\n* How to reuse the build logic?\n    * within a project, and among projects\
  \ -->\n"
- '## Check your understanding


  - What is the build life cycle of a software project?

  - In the context of Software Engineering, what is build automation?

  - What can you expect, in general, from a build automation tool?

  - In the context of build automation, what is dependency locking? Why is it necessary?

  - In a Python project, what would you use Poetry for?

  - Where would you release a Python project on Test PyPI? When on PyPI?

  - What is Test PyPI? What''s its purpose?

  - What are the steps to release a Python project via Poetry?

  '
id: BuildAutomation-3
model_name: llama-3.3-70b-versatile
model_provider: groq
prompt_template: "You are a teacher in the Software Engineering course, for the Digital\
  \ Transformation and Management master programme. \n\nYour task is to create a structured\
  \ checklist for evaluating student answers to each question.\n\nFor each question,\
  \ you should identify:\n\n1. **Core** - The essential elements that MUST be present\
  \ in a perfect answer to address the most important part of the question. These\
  \ are the fundamental concepts, definitions, or explanations that directly answer\
  \ what is being asked.\n\n2. **Important Details** - Significant additional details\
  \ that should be mentioned to enrich the answer. These go beyond the core but are\
  \ important for a complete understanding.\n\n3. **Additional Details** - Optional\
  \ supplementary details that can further improve the answer. These might include\
  \ examples, comparisons, background context, or motivational aspects that add depth\
  \ but are not strictly necessary.\n\nEach item in the lists should be specific,\
  \ verifiable, and actionable - not vague or fluffy.\n\nOnly extract the properties\
  \ mentioned in the '{class_name}' function.\n\nQuestion is:\n    {question}\n\n\
  Below are snippets from the course material that may help you answer the question:\n\
  \n{help}"
question: What can you expect, in general, from a build automation tool?
