core:
- Unit tests are essential for understanding why the software doesn't work
- Skipping unit testing can lead to a lack of understanding of the software's functionality
  at a granular level
details_additional:
- Clean boundaries and clear scope are necessary for effective testing, including
  well-defined APIs and modularization
- Test plans should be conceived to test that each component performs its intended
  function correctly
details_important:
- Integration tests only verify that the software works, but don't provide insight
  into why it doesn't work
- A well-maintained engineering product must have tests at all granularity levels,
  including unit tests
helps:
- '## Check your understanding (pt. 2)


  - What is the problem in skipping unit testing and just focus on integration testing?

  - Why one may want to have automated tests in a software project?

  - What issues may arise in the long run when a software project is lacking automated
  testing?

  - Why is reproducibility important in testing? How to achieve it?

  - What is test code? How to separate it from the main code? Why?

  - What is test driven development (TDD)?

  - In what sense can software test act as a form of specification?

  - What is technical debt? How is it related to software testing?

  - How to deal with a project which was not following TDD since the very beginning?

  '
- '## Check your understanding (pt. 2)


  - What is the problem in skipping unit testing and just focus on integration testing?

  - Why one may want to have automated tests in a software project?

  - What issues may arise in the long run when a software project is lacking automated
  testing?

  - Why is reproducibility important in testing? How to achieve it?

  - What is test code? How to separate it from the main code? Why?

  - What is test driven development (TDD)?

  - In what sense can software test act as a form of specification?

  - What is technical debt? How is it related to software testing?

  - How to deal with a project which was not following TDD since the very beginning?

  '
- "## Testing scope (pt. 2)\n\n> A well-maintained engineering product _must_ have\
  \ tests at __all granularity levels__\n\n* But why?\n  - after all, if the _end-to-end_\
  \ test passes...\n  - ... then all the _unit_ and _integration_ tests should pass\
  \ as well, right?\n\n<br>\n\n* Yes, but:\n  - tests are not only about _verifying_\
  \ that the software works\n  - they are particularly useful to _understand_ __why__\
  \ it _doesn't_ work\n"
- "## Testing scope (pt. 2)\n\n> A well-maintained engineering product _must_ have\
  \ tests at __all granularity levels__\n\n* But why?\n  - after all, if the _end-to-end_\
  \ test passes...\n  - ... then all the _unit_ and _integration_ tests should pass\
  \ as well, right?\n\n<br>\n\n* Yes, but:\n  - tests are not only about _verifying_\
  \ that the software works\n  - they are particularly useful to _understand_ __why__\
  \ it _doesn't_ work\n"
- "## Testing software before it is ready: _boundaries_\n\n> __Problem__: how is it\
  \ possible to test code that *does not exist*?\n- More in general: how to design\
  \ a testbed for an engineering product that is not prototypied yet?\n\n<br>\n\n\
  - **Clean boundaries**: the component must have a well-defined interface with the\
  \ rest of the world.\n    + in software, it means that the component has a *well-defined\
  \ Application Programming Interface* (API).\n    + our artifact must be **modularized**\
  \ correctly\n        * (this also helps with development, simplicity and maintenance)\n\
  \n- **Clear scope**: well engineered (software) components usually *do one thing\
  \ well*.\n    + test plans are conceived to test that the one thing is performed\
  \ correctly.\n"
id: Commonsense-16
model_name: llama-3.3-70b-versatile
model_provider: groq
prompt_template: "You are a teacher in the Software Engineering course, for the Digital\
  \ Transformation and Management master programme. \n\nYour task is to create a structured\
  \ checklist for evaluating student answers to each question.\n\nFor each question,\
  \ you should identify:\n\n1. **Core** - The essential elements that MUST be present\
  \ in a perfect answer to address the most important part of the question. These\
  \ are the fundamental concepts, definitions, or explanations that directly answer\
  \ what is being asked.\n\n2. **Important Details** - Significant additional details\
  \ that should be mentioned to enrich the answer. These go beyond the core but are\
  \ important for a complete understanding.\n\n3. **Additional Details** - Optional\
  \ supplementary details that can further improve the answer. These might include\
  \ examples, comparisons, background context, or motivational aspects that add depth\
  \ but are not strictly necessary.\n\nEach item in the lists should be specific,\
  \ verifiable, and actionable - not vague or fluffy.\n\nOnly extract the properties\
  \ mentioned in the '{class_name}' function.\n\nQuestion is:\n    {question}\n\n\
  Below are snippets from the course material that may help you answer the question:\n\
  \n{help}"
question: What is the problem in skipping unit testing and just focus on integration
  testing?
